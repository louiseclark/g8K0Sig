/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "LinPolPDF.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(LinPolPDF) 

 LinPolPDF::LinPolPDF(const char *name, const char *title, 
	      RooAbsReal& _cosY,
	      RooAbsReal& _R) :
   RooHSEventsPDF(name,title),
   cosY("cosY","cosY",this,_cosY),
   R("R","R",this,_R)
 { 
   MakeSets();
   cosY.SetName(_cosY.GetName());
   R.SetName(R.GetName());
 } 


 LinPolPDF::LinPolPDF(const LinPolPDF& other, const char* name) :  
   RooHSEventsPDF(other,name),
   cosY("cosY",this,other.cosY),
   R("R",this,other.R)
 { 
   MakeSets();
   cosY.SetName(other.cosY.GetName());
   R.SetName(other.R.GetName());
   if(fEvTree) SetEvTree(fEvTree,fCut);//Needs fProxSet filled first
 } 
void LinPolPDF::MakeSets(){
   fProxSet.push_back(&cosY);
   fParSet.push_back(&R);
   InitSets();
}



 Double_t LinPolPDF::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t alpha=-0.980; 

   Double_t result=1+alpha*cosY*R;
   if (result<0) result=1.0e-12;
   return result;
 } 

Double_t LinPolPDF::evaluateMC(const vector<Float_t> *vars,const  vector<Int_t> *cats) const {
// ENTER IDENTICAL EXPRESSION TO evaluate() IN TERMS OF MC VARIABLE ARGUMENTS HERE
   Double_t mcCosY=(*vars)[fTreeEntry*fNvars+1];
   
   Double_t alpha=-0.980;

   Double_t result = 1+alpha*mcCosY*R;
   if (result<0) result=1.0e-12;
   return result;

}


